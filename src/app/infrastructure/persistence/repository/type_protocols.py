from collections.abc import Sequence
from typing import Any, Protocol, TypeVar, runtime_checkable

T = TypeVar("T")


@runtime_checkable
class SQLReadRepository(Protocol[T]):
    async def find_by_id(self, entity_id: str, include_deleted: bool = False) -> T | None: ...
    async def find_all(
        self, offset: int = 0, limit: int = 100, include_deleted: bool = False
    ) -> list[T]: ...
    async def find_by_ids(
        self, entity_ids: list[str], include_deleted: bool = False
    ) -> list[T]: ...
    async def find_where(self, include_deleted: bool = False, **conditions: Any) -> list[T]: ...
    async def exists(self, entity_id: str) -> bool: ...
    async def count(self, include_deleted: bool = False) -> int: ...


@runtime_checkable
class SQLWriteRepository(Protocol[T]):  # type: ignore[misc]
    async def create(self, data: dict[str, Any]) -> T: ...
    async def update(self, entity_id: str, data: dict[str, Any]) -> T | None: ...
    async def delete(self, entity_id: str, hard: bool = False) -> bool: ...


@runtime_checkable
class SQLBulkRepository(Protocol[T]):
    async def create_many(self, items: Sequence[dict[str, Any]]) -> list[T]: ...
    async def update_many(self, entity_ids: list[str], data: dict[str, Any]) -> int: ...
    async def delete_many(self, entity_ids: list[str], hard: bool = False) -> int: ...


@runtime_checkable
class SQLPaginatedRepository(Protocol[T]):
    async def find_paginated(
        self, page: int = 1, page_size: int = 20, include_deleted: bool = False
    ) -> tuple[list[T], int]: ...
    async def find_by_cursor(
        self, cursor: str | None = None, limit: int = 20, include_deleted: bool = False
    ) -> list[T]: ...


@runtime_checkable
class SQLUpsertRepository(Protocol[T]):  # type: ignore[misc]
    async def upsert(
        self,
        data: dict[str, Any],
        conflict_fields: list[str],
        update_fields: list[str] | None = None,
    ) -> T: ...
    async def find_or_create(
        self, defaults: dict[str, Any] | None = None, **filters: Any
    ) -> tuple[T, bool]: ...


@runtime_checkable
class SQLSoftDeleteRepository(Protocol[T]):  # type: ignore[misc]
    async def restore(self, entity_id: str) -> T | None: ...


@runtime_checkable
class SQLRepository(
    SQLReadRepository[T],
    SQLWriteRepository[T],
    SQLBulkRepository[T],
    SQLPaginatedRepository[T],
    SQLUpsertRepository[T],
    SQLSoftDeleteRepository[T],
    Protocol[T],
):
    pass


@runtime_checkable
class DocumentReadRepository(Protocol[T]):
    async def find_by_id(self, document_id: str) -> T | None: ...
    async def find_one(self, filter: dict[str, Any]) -> T | None: ...
    async def find_many(
        self,
        filter: dict[str, Any] | None = None,
        skip: int = 0,
        limit: int = 100,
        sort: list[tuple[str, int]] | None = None,
    ) -> list[T]: ...
    async def count_documents(self, filter: dict[str, Any] | None = None) -> int: ...
    async def distinct(self, field: str, filter: dict[str, Any] | None = None) -> list[Any]: ...


@runtime_checkable
class DocumentWriteRepository(Protocol[T]):
    async def insert_one(self, document: dict[str, Any]) -> T: ...
    async def insert_many(self, documents: list[dict[str, Any]]) -> list[T]: ...
    async def update_one(
        self, filter: dict[str, Any], update: dict[str, Any], upsert: bool = False
    ) -> T | None: ...
    async def update_many(self, filter: dict[str, Any], update: dict[str, Any]) -> int: ...
    async def delete_one(self, filter: dict[str, Any]) -> bool: ...
    async def delete_many(self, filter: dict[str, Any]) -> int: ...
    async def replace_one(
        self, filter: dict[str, Any], replacement: dict[str, Any], upsert: bool = False
    ) -> T | None: ...


@runtime_checkable
class DocumentAggregateRepository(Protocol[T]):  # type: ignore[misc]
    async def aggregate(self, pipeline: list[dict[str, Any]]) -> list[dict[str, Any]]: ...


@runtime_checkable
class DocumentRepository(
    DocumentReadRepository[T],
    DocumentWriteRepository[T],
    DocumentAggregateRepository[T],
    Protocol[T],
):
    pass


@runtime_checkable
class KeyValueRepository(Protocol[T]):
    async def get(self, key: str) -> T | None: ...
    async def set(self, key: str, value: T, ttl: int | None = None) -> bool: ...
    async def delete(self, key: str) -> bool: ...
    async def exists(self, key: str) -> bool: ...
    async def get_many(self, keys: list[str]) -> dict[str, T | None]: ...
    async def set_many(self, items: dict[str, T], ttl: int | None = None) -> bool: ...
    async def delete_many(self, keys: list[str]) -> int: ...
    async def keys(self, pattern: str = "*") -> list[str]: ...
    async def ttl(self, key: str) -> int | None: ...
    async def expire(self, key: str, seconds: int) -> bool: ...


@runtime_checkable
class HashRepository(Protocol[T]):
    async def hget(self, key: str, field: str) -> T | None: ...
    async def hset(self, key: str, field: str, value: T) -> bool: ...
    async def hgetall(self, key: str) -> dict[str, T]: ...
    async def hdel(self, key: str, *fields: str) -> int: ...
    async def hexists(self, key: str, field: str) -> bool: ...


@runtime_checkable
class ListRepository(Protocol[T]):
    async def lpush(self, key: str, *values: T) -> int: ...
    async def rpush(self, key: str, *values: T) -> int: ...
    async def lpop(self, key: str) -> T | None: ...
    async def rpop(self, key: str) -> T | None: ...
    async def lrange(self, key: str, start: int, stop: int) -> list[T]: ...
    async def llen(self, key: str) -> int: ...
